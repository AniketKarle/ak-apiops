<!--
    - Policies are applied in the order they appear.
    - Position <base/> inside a section to inherit policies from the outer scope.
    - Comments within policies are not preserved.
-->
<!-- Add policies as children to the <inbound>, <outbound>, <backend>, and <on-error> elements -->
<policies>
	<!-- Throttle, authorize, validate, cache, or transform the requests -->
	<inbound>
		<base />
		<set-header name="Authorization" exists-action="override">
			<value>@{
                // 1) Construct the Base64Url-encoded header
                var header = new { typ = "JWT", alg = "HS256" };
                var jwtHeaderBase64UrlEncoded = Convert.ToBase64String(Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(header))).Replace("/", "_").Replace("+", "-"). Replace("=", "");
                // As the header is a constant, you may use this equivalent Base64Url-encoded string instead to save the repetitive computation above.
                // var jwtHeaderBase64UrlEncoded = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9";

                // 2) Construct the Base64Url-encoded payload 
                var exp = new DateTimeOffset(DateTime.Now.AddMinutes(10)).ToUnixTimeSeconds();  // sets the expiration of the token to be 10 minutes from now
                var username = "john_doe";
                var payload = new { exp, username };
                var jwtPayloadBase64UrlEncoded = Convert.ToBase64String(Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(payload))).Replace("/", "_").Replace("+", "-"). Replace("=", "");

                // 3) Construct the Base64Url-encoded signature                
                var signature = new HMACSHA256(Encoding.UTF8.GetBytes("hashing-secret")).ComputeHash(Encoding.UTF8.GetBytes($"{jwtHeaderBase64UrlEncoded}.{jwtPayloadBase64UrlEncoded}"));
                var jwtSignatureBase64UrlEncoded = Convert.ToBase64String(signature).Replace("/", "_").Replace("+", "-"). Replace("=", "");

                // 4) Return the HMAC SHA256-signed JWT as the value for the Authorization header
                return $"Bearer {jwtHeaderBase64UrlEncoded}.{jwtPayloadBase64UrlEncoded}.{jwtSignatureBase64UrlEncoded}"; 
            }</value>
		</set-header>
		<!--<mock-response status-code="200" content-type="application/json" />-->
		<return-response>
			<set-status code="200" reason="ok" />
			<!--<set-header name="Authorization" exists-action="override">
                <value>@("Bearer " + context.Variables["jwtToken"])</value>
            </set-header>-->
			<set-body>hello world</set-body>
		</return-response>
	</inbound>
	<!-- Control if and how the requests are forwarded to services  -->
	<backend>
		<base />
	</backend>
	<!-- Customize the responses -->
	<outbound>
		<base />
	</outbound>
	<!-- Handle exceptions and customize error responses  -->
	<on-error>
		<base />
	</on-error>
</policies>